# `equals`는 일반 규약을 지켜 재정의하라

### `equals` 메서드를 재정의하지 않는 것이 권장되는 경우

* **각 인스턴스가 본질적으로 고유한 경우**
  * e.g. 값을 표현하는 게 아니라 동작하는 개체를 표현하는 클래스(Thread)
* **인스턴스의 '논리적 동치성'을 검사할 일이 없는 경우**
  * `java.util.reges.Pattern`
    * `equals`를 재정의하여 두 Pattern의 인스턴스가 같은 정규표현식인지 검사함(논리적 동치성 검사)
    * `Object`의 `equals`만으로 비교할 수 있음
* **상위 클래스에서 재정의한 `equals`가 하위 클래스에도 들어맞을 경우**
  * `Set` 구현체는 `AbstractSet`이 구현한 `equals`를 상속받아 쓰고, `List` 구현체들은 `AbstractList`로부터, `Map` 구현체들은 `AbstractMap`으로부터 상속받아 그대로 사용한다.
* **클래스가 `private`이거나 `package-private`이고 `equals` 메서드를 호출할 일이 없는 경우**
  * `equals`가 실수로라도 호출되는 것을 방지하고 싶을 때, 다음과 같이 구현하자.
    ```java
    @Override 
    public boolean equals(Object o) {
        throw new AssertionError();
    }
    ```

<br>



### `equals`를 재정의해야 되는 경우

* 객체 식별성(두 객체가 물리적으로 같은가)가 아닌, **논리적 동치성을 확인**해야 되는데, **상위 클래스의 `equals`가 논리적 동치성을 비교하도록 재정의 되지 않았을 경우**
  * e.g. 값 클래스
    * 값 클래스라고 해도, 값이 같은 인스턴스가 둘 이상 만들어지지 않음이 보장되는 **인스턴스 통제 클래스**라면 **`equals`를 정의하지 않아도 된다**. 
    * `Enum`도 논리적으로 같은 인스턴스가 2개 이상 만들어지지 않기 때문에 논리적 동치성과 객체 식별성이 사실상 같은 의미가 된다.

<br>



### `equals` 메서드 재정의 시, 지켜야될 규약

`equals` 메서드는 **동치관계**를 구현하며, 다음을 만족한다.
* **반사성**: `null`이 아닌 모든 참조 값 `x`에 대해, `x.equals(x)`는 `true`이다.
* **대칭성**: `null`이 아닌 모든 참조 값 `x`, `y`에 대해, `x.equals(y)`가 `true`이면 `y.equals(x)`도 `true`이다.
* **추이성**: `null`이 아닌 모든 참조 값 `x`, `y`, `z`에 대해 `x.equals(y)`가 `true`이고 `y.equals(z)`도 `true`이면, `x.equals(z)`도 `true`이다.
* **일관성**: `null`이 아닌 모든 참조 값 `x`, `y`에 대해, `x.equals(y)`를 반복해서 호출하면 항상 `true`를 반환하거나 항상 `false`를 반환한다.
* **`null`-아님**: `null`이 아닌 모든 참조 값 `x`에 대해 `x.equals(null)`은 `false`이다.

<br>



### 동치성

* 집합을 서로 같은 원소들로 이뤄진 부분집합으로 나누었을 때, 부분집합을 동치류라고 한다.
* **동치관계를 만족하기 위한 다섯 요건**
  * **반사성**
    * 객체는 자기 자신과 같아야 한다.
      * 클래스의 인스턴트를 컬렉션에 넣고, `contain`연산을 한다면 결과는 `true`여야 함
  * **대칭성**
    * 두 객체는 서로에 대한 동치 여부에 똑같이 답해야 한다.
  * **추이성**
    * 첫 번째 객체와 두 번째 객체가 같고, 두 번째 객체와 세 번째 객체가 같다면, 첫 번째 객체와 세 번째 객체도 같아야 한다.
  * **일관성**
    * 어느 하나 혹은 두 객체가 모두 수정되지 않는 한, 두 객체가 같다면, 앞으로도 영원히 같아야 한다.
      * 불변 클래스로 만들기로 했다면, `equals`가 한 번 같다고 한 객체와는 영원히 같다고 답하고, 다르다고 한 객체와는 영원히 다르다고 답하도록 해야한다.
  * `null`-아님
    * 모든 객체가 `null`과 같지 않아야 한다.
    * `o.equals(null)`이 `true`를 반환하면 안된다.



<br>



### equals 재정의 시, 주의사항

* `equals`를 재정의할 땐, `hashCode`도 반드시 재정의하자
* 너무 복잡하게 해결하려 하지 말자!
  * 필드들의 동치성만 검사해도 `equals`규약을 어렵지 않게 지킬 수 있을 것이다.
  * 별칭은 비교하지 않는게 좋다.
  * `Object`외의 타입을 매개변수로 받는 `equals` 메서드는 선언하지 말자.
    * `Object.equals`를 재정의한 것이라고 할 수 없다.
    * 재정의가 아닌 다중정의다.
  * `AutoValue`프레임워크를 통해 `equals` 테스트를 진행할 수 있다.

<br>

### 정리

* 꼭 필요한 경우가 아니면 `equals`를 재정의하지 말자. (많은 경우에 `Object`의 `equals`가 원하는 비교를 정확히 수행해 줄 것이다.)
* 재정의할 때는 해당 클래스의 핵심 필드를 모두 빠짐없이, 다섯 가지 규약을 확실히 지켜가며 비교해야 될 것이다.