# 클래스와 멤버의 접근 권한을 최소화하라

잘 설계된 컴포넌트는 모든 내부 구현을 완벽히 숨겨서 구현과 API를 깔끔히 분리한다.

**오직 API를 통해서만 다른 컴포넌트와 소통**하며 **서로의 내부 동작 방식에는 개의치 않는다.**

정보은닉(캡슐화)는 소프트웨어 설계의 근간이 되는 원리이다!



<br>



### 정보 은닉의 장점

* **시스템 개발 속도를 높임**
  * 여러 컴포넌트를 병렬로 개발할 수 있다.
* **시스템 관리 비용을 낮춤**
  * 각 컴포넌트를 파악하며 디버깅할 수 있고, 다른 컴포넌트로 교체하는 부담도 적다.
* **성능 최적화에 도움을 줌**
  * 완성된 시스템을 프로파일링해 최적화할 컴포넌트를 정한 다음, 해당 컴포넌트만 최적화할 수 있다.
* **소프트웨어 재사용성을 높임**
* **큰 시스템을 만드는 난이도를 낮춤**
  * 시스템 전체가 개발되지 않아도 개별 컴포넌트의 동작을 검증할 수 있다.

<br>

### 접근 제어 메커니즘

* 자바에서 **정보은닉**을 위한 다양한 장치 중 하나이다.
* **클래스, 인터페이스, 멤버의 접근성(접근 허용 범위)를 명시**한다.
  * 각 요소의 접근성은 그 요소가 선언된 위치와 접근 제한자로 정해진다.
* **기본 원칙**
  * **모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다!**



### 톱레벨 클래스와 인터페이스의 접근 제한자

* **톱레벨(가장 바깥) 클래스와 인터페이스에는 package-private과 public 접근 제한자를 사용할 수 있다.**
* **`public` **
  * 공개 API로 사용된다.
  * API가 되므로 하위 호환을 위하 영원히 관리해줘야 한다.
* **`package-private`**
  * 해당 패키지 안에서만 사용할 수 있다.
  * 클라이언트에 영향 없이 다음 배포에서 수정, 교체, 제거 할 수 있다.
  * `package-private` 안에 `private static`으로 중접한다면 바깥 클래스 하나에서만 접근할 수 있다.
* 패키지 외부에서 사용할 이유가 없다면 `package-private`으로 선언하자.



### 멤버 접근 제한자

* 멤버(필드, 메서드, 중첩 클래스, 중첩 인터페이스)에는 네 가지 접근 제한자를 사용할 수 있다.
* `private`
  * 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다.
* `package-private`
  * 멤버가 소속된 패키지 안의 모든 클래스에서 접근할 수 있다.
  * 접근 제한자를 명시하지 않았을 때 적용되는 패키지 수준이다.
  * 단, 인터페이스의 멤버는 기본적으로 `public`이 적용된다.
* `protected`
  * `package-private`의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근할 수 있다.
* `public`
  * 모든 곳에서 접근할 수 있다.

<br>



### 접근 제한자 설정 권장 가이드

1. 공개 API 외의 모든 멤버는 `private`으로 만들자.
2. 오직 같은 패키지의 다른 클래스가 접근하는 멤버에 한하여 `package-private`로 설정하자.



<br>

### 접근 제한자 주의사항

* 멤버의 접근 수준을 `package-private`에서 `protected`로 바꾸면, 그 멤버에 접근할 수 있는 대상 범위가 넓어지기 때문에, 고려해야 되는 사항이 많아진다. (`protected` 멤버의 수는 적을수록 좋다 !)
* 멤버 접근성을 좁힐 수 없는 경우
  * 상위 클래스의 메서드를 재정의할 때는 접근 수준을 상위 클래스보다 좁게 설정할 수 없다 !
    * 이러한 규칙은 상위 클래스의 인스턴스가 하위 클래스의 인스턴스로 대체하여 사용할 수 있어야 한다는 규칙을 지키기 위해 필요하다.
* 코드를 테스트하는 목적으로 적상한 수준으로 접근 제한자의 범위를 넓혀도 괜찮다.
  * e.g. `public` 클래스의 `private` 멤버를 `package-private`로 변경하는 것 (그 이상은 안됨!)
  * 테스트만을 위한 클래스, 인터페이스, 멤버를 공개 API로 만들면 안됨
* `public` 클래스의 인스턴스 필드는 되도록 `public`이 아니어야 한다.
  * 필드가 가변 객체를 참조하거나, `final`이 아닌 인스턴스 필드를 `public`으로 선언하면 그 필드에 담을 수 있는 값을 제한할 수 없게 된다. 
    * 불변식을 보장할 수 없게 된다.
    * 필드가 수정될 때 다른 작업을 할 수 없기 때문에 `public` 가변 필드를 갖는 클래스는 일반적으로 안전하지 않다.
  * 하지만, 해당 클래스가 **추상 개념을 완성하기 위해 꼭 필요한 구성요소의 상수**라면 `public static final` 필드로 공개해도 된다.
    * 가변객체를 참조한다면, `final`이 아닌 필드에도 모두 변화가 적용되기 때문에, **반드시 기본 타입 값이나 불변 객체를 참조**해야 된다 !
    * 클래스에서 `public static final` 배열 필드를 두거나 이 필드를 반환하는 접근자 메서드를 제공하면 안된다 !

<br>

### 모듈 시스템

* 자바 9에서 모듈(패키지들의 묶음) 시스템이 도입되면서 암묵적인 접근 수준이 추가되었다.
  * 숨겨진 패키지 안에 있는 `public` 클래스의 `pulbic` 혹은 `protected` 멤버
    * 접근 수준이 `public`, `protected`이지만, 범위가 모듈 내부로 한정되게 된다.
* `protected` 혹은 `public` 멤버라도 해당 패키지를 공개하지 않았다면 모듈 외부에서 접근할 수 없다.
* 모듈 시스템을 활용하면 클래스를 외부에 공개하지 않으면서도 같은 모듈을 이루는 패키지 사이에서는 자유롭게 공유할 수 있다.
* 모듈에 적용되는 접근 방법은 모듈의 JAR 파일을 자신의 모듈 경로가 아닌 애플리케이션의 클래스패스에 두면 그 모듈 안의 패키지는 마치 모듈이 없는 것처럼 동작하게 된다.
  * 모듈의 공개여부와 상관없이, `public` 클래스가 선언한 모든 `public`, `protected` 멤버를 모듈 밖에서도 사용할 수 있게 됨
  * e.g. JDK (자바 라이브러리에서 공개하지 않은 패키지들은 해당 모듈 밖에서 절대 접근할 수 없다.)

<br>



### 정리

* **프로그램 요소의 접근성은 가능한 한 최소한**으로 하자. 꼭 필요한 것으로 `public` API를 설계하자!
* `public` 클래스는 상수용 `public static final` 필드 외에는 어떠한 `public` 필드를 가지면 안된다. (**`public static final` 필드가 참조하는 객체가 불변**인지 확인하자 !)