# 변경 가능성을 최소화하라

불변 클래스는 인스턴스의 내부 값을 수정할 수 없기 때문에 인스턴스에 간직된 정보는 고정되어 객체가 파괴되는 순간까지 달라지지 않는다.

불변 클래스는 가변 클래스보다 설계하고 구현하기 쉬우며, 오류가 생길 여지도 적어 안전하다.

* 불변 클래스의 예
  * `String`, 기본 타입의 박싱된 클래스, `BigInteger`, `BigDecimal`

<br>



### 불변 클래스를 만들기 위한 규칙

* **객체의 상태를 변경하는 메서드(변경자)를 제공하지 않는다.**
* **클래스를 확장할 수 없도록 한다.**
  * 하의 클래스에서 객체의 상태를 변경시키는 것을 막아준다.
* **모든 필드를 final로 선언한다.**
  * 시스템이 강제하는 수단을 이용해 설계자의 의도를 명확히 드러내는 방법이다.
* **모든 필드를 private으로 선언한다.**
  * 필드가 참조하는 가변 객체를 클라이언트에서 직접 접근해 수정하는 것을 막아준다.
  * 다음 릴리스에서 내부 표현을 바꾸지 못하므로 권장되지 않는다.
* **자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.**
  * 클래이언트에서 가변 객체를 참조하는 필드가 있다면 클라이언트에서 객체의 참조를 얻을 수 없도록 해야된다.
    * 생성자, 접근자, readObject 메서드 모두에서 방어적 복사 수행



<br>



### 불변 객체 사용 장점

* **단순하다**
  * 생성된 시점의 상태를 파괴될 때까지 가지고 있기 때문에 사용하기에 가변 객체에 비해 단순하게 사용할 수 있다.
* **근본적으로 스레드에 안전하여 따로 동기화할 필요가 없다.**
  * 여러 스레드를 동시에 사용해도 절대 훼손되지 않는다.
  * 불변 객체에 대해서는 어떤 스레드도 다른 스레드에 영향을 줄 수 없으니 안심하고 공유하여 사용할 수 있다.
*  **불변 객체는 자유롭게 공유할 수 있음은 물론, 불변 객체끼리는 내부 데이터를 공유할 수 있다.**
* **실패 원자성을 제공한다.**
  * 메서드에서 예외가 발생한 후에도 해당 객체는 메서드 호출 전과 같은 상태를 유지할 수 있음



<br>

### 불변 객체 사용의 단점

* 값이 다르면 반드시 독립된 객체로 만들어야 된다.
  * 값의 가짓수가 많다면 이를 모두 만드는 데 비용이 많이 들 수 있다.
    * 계산 비용이 큰 값을 나중에 계산하여 `fianl`이 아닌 필드에 캐시를 하여 계산 비용을 절감할 수 있다.



<br>

### 정리

* Getter가 있다고 무조건 Setter를 만들진 말자. 클래스가 꼭 필요한 경우가 아니라면 불변이어야한다.
* 불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄이자.
  * 꼭 변경해야 하는 필드를 제외한 나머지를 `fianl`로 선언하자.
  * 합당한 이유가 없다면 모든 필드는 `private fianl`이어야 한다 !
* 생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다.

