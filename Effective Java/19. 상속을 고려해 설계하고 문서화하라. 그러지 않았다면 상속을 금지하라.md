# 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

### 상속 클래스를 사용할 시 지켜야 할 제약

* 상속용 클래스는 **재정의할 수 있는 메서드를 내부적으로 어떻게 사용하는지 문서**로 남겨야 한다.
  * 어떤 순서로 메서드를 호출하는지
  * 각각의 호출 결과가 이어지는 처리에 어떤 영향을 주는지
  * 재정의 가능 메서드를 호출할 수 있는 모든 상황을 문서로 남겨야 한다.
    * e.g. 백그라운드나 스레드나 정적 초기화 과정에도 호출이 일어날 수 있음
  * 이 때, 재정의 할 수 있는 것은 `public`과 `protected` 메서드 중 `final`이 아닌 모든 메서드를 뜻한다.
  * `Implementation Requirements`
    * 해당 메서드의 내부 동작 방식을 설명하는 곳
    * 메서드 주석에 `implSpec` 태그를 붙여주면 자바독 도구가 생성해준다.
  * 클래스를 안전하게 상속하기 위해서 **내부 구현 방식을 설명**해야 한다.
* 효율적인 하위 클래스를 생성하기 위해서 상속을 위한 설계 뿐만 아니라 **클래스의 내부 동작 과정 중 끼어들 수 있는 훅을 잘 선별하여 `protected` 메서드 형태로 공개**해야 할 수도 있다.
  * 드물게는 `protected` 필드로 공개해야 할 수 있다.
  * `protected` 메서드를 정하는 것은 **실제 하위 클래스를 만들어 테스트**해보는 것이 최선의 방법이다.
    * `protected`메서드는 내부 구현에 해당되므로 가능한 적으면서, 적게 노출해서 상속으로 얻는 이점이 없어지지 않도록 주의해야 한다.
  * **상속용으로 설계한 클래스는 반드시 배포 전에 하위 클래스를 만들어 검증해야 한다.**
* **상속용 클래스의 생성자는 직·간접적 어떠한 것이라도 재정의 가능 메서드를 호출해서는 안된다.**
  * 상위 클래스의 생성자가 하위 클래스의 생성자보다 먼저 실행되므로 하위 클래스에서 재정의한 메서드가 하위 클래스의 생성자보다 먼저 호출된다.
    * 재정의한 메서드가 하위 클래스의 생성자에서 초기화하는 값에 의존한다면, 의도하지 않은 대로 동작할 수 있다.
  * `private`, `final`, `static` 메서드는 재정의가 불가능하니 생성자에서 안심하고 호출해도 된다.
* **`Cloneable`, `Serializable` 인터페이스 중 하나라도 구현한 클래스를 상속하는 것은 일반적으로 좋지 않은 방법이다.**
  * `clone`과 `readObject` 새로운 객체를 만들기 때문에 생성자와 비슷한 효과를 낸다.
    * `clone`의 경우 하위 클래스의 `clone` 메서드가 복제본의 상태를 올바른 상태로 수정하기 전에 재정의한 메서드를 호출한다.
    * `readObject`의 경우 하위 클래스의 상태가 역직렬화되기 전에 재정의한 메서드부터 호출하게 된다.
  * 상속용 클래스에서 `Cloneable`이나 `Serializable`을 구현할지 정해야 된다면, 구현할 때 따르는 제약도 생성자와 비슷하다는 점의 주의하자.
  * 즉, `clone`과 `readObject` 모두 직간접적으로 재정의 가능 메서드를 호출해서는 한된다.
* **`Serializable`을 구현한 상속용 클래스가 `readSolve`나 `writeReplace` 메서드를 갖는다면 이 메서드는 `private`이 아닌 `protected`로 선언해야 한다.**
  * `private`로 선언하면 하위 클래스에서 무시되기 때문이다.
* **상속용으로 설계하지 않은 클래스는 상속을 금지하자.**
  * 일반 구체 클래스의 경우 `final`도 아니고 상속용으로 설계되거나 문서화되지 않았지만, 클래스에 변화가 생길 때마다 하위 클래스를 오동작하게 만들 수 있다.
  * 상속을 금지하는 방법
    * 클래스를 `final`로 선언
    * 모든 생성자를 `private`이나 `package-private`으로 선언하고 정적 팩터리를 만든다.
  * 구체 클래스를 꼭 상속해야 된다면, 클래스 내부에 재정의 가능 메서드를 사용하지 않게 만들고 이 사실을 문서에 남기자.



<br>

## 정리

* 하위 클래스의 오동작을 방지하기 위해서, **상속용 클래스를 설계**할 때는 클래스 내부에서 스스로 어떻게 사용하는지 모두 **문서화**하고 **문서화한 것은 반드시 지켜야한다**.
* 일부 메서드를 `protected`로 제공해야 될 수도 있으니, 명확한 이유가 없으면 상속을 하지 않는 것이 나을 수 있다.
* 상속을 금지하기 위해서 클래스를 fianl로 선언하거나 생성자를 외부에서 접근할 수 없도록 만들면 된다.

  