# 로 타입은 사용하지 말라

### 제네릭

* 제네릭 사용의 장점
  * 컬렉션이 담을 수 있는 타입을 컴파일러에게 알려주게 되면서 **컴파일러가 알아서 형변환 코드를 추가**할 수 있게 된다.
  *  **엉뚱한 타입의 객체를 넣으려는 시도를 차단**하여 **안전하고 명확한 프로그램**을 만들 수 있다.
* 제네릭 사용의 단점
  * 코드가 복잡해질 수 있다.

<br>



### 제네릭 클래스 (제네릭 인터페이스)

* **클래스와 인터페이스 선언에 타입 매개변수**가 쓰이면, 이를 제**네릭 클래스 (제네릭 인터페이스)**라고 한다.
  * e.g) `List` 인터페이스는 원소의 타입을 나타내는 타입 매개변수 `E`를 받는다. (`List<E>`)
* **제네릭 클래스와 제네릭 인터페이스**를 통틀어 **제네릭 타입**이라고 한다.
* 각각의 제네릭 타입은 일련의 매개변수화 타입을 정의한다.
  * `클래스(혹은 인터페이스)<실제(actual) 타입 매개변수>`
* 제네릭 타입을 하나 정의하면 그에 딸린 **로 타입**도 함께 정의딘다.

<br>  

### 로타입

* 로타입
  * **제네릭 타입에서 타입 매개변수를 전혀 사용하지 않은 것**을 말한다.
  * `List`: `List<E>`의 로타입
* **로 타입**은 **타입 선언에서 제네릭 타입 정보가 지워진 것처럼 동작**한다. (제네릭을 사용하기 전의 코드와 호환성을 위해 사용)
* 로 타입과 매개변수화 타입의 차이점
  * 로 타입은 제네릭을 사용하지 않겠다는 의미이고, 매개변수화 타입은 모든 타입을 허용한다는 의미이다.
  * e.g) `List`와 `List<Object>`
    * `List<String>`은 로 타입인 `List`의 하위 타입이지만, `List<Object>`의 하위 타입은 아니다.
    * `List<Object>`와 같은 매개변수화 타입과 달리 `List`같은 **로 타입을 사용하면 타입 안정성을 잃게 된다**.

<br>

### 와일드카드 타입

* 제네릭 타입을 쓰고 싶지만 실제 타입이 무엇인지 신경 쓰고 싶지 않다면 로 타입 대신 물음표(`?`)를 사용하자.
  * **어떤 타입이라도 담을 수 있는 가장 범용적인 매개변수화 타입**이다.
  * `Set<?>`: `Set<E>`의 와일드카드 타입
* 로 타입과 와일드카드 타입의 차이점
  * 로 타입 컬렉션에는 아무 원소나 넣을 수 있으니 타입 불변식을 훼손하기 쉽다.
  * 반면, `Collection<?>`에는 `null`이외의 어떤 원소도 넣을 수 없으므로 타입 불변식을 훼손하지 않는다.
  * **와일드카드 타입**은 any타입이 아닌, **unknown 타입**이다!

<br>

### 로 타입을 사용해야 되는 경우

* `class` 리터럴 타입
  * 자바 명세는 `class` 리터럴에 매개변수화 타입을 사용하지 못하게 했다. (배열과 기본 타입은 허용)
    * `List.class`, `String[].class`, `int.class`는 허용하지만, `List<String>.class`, `List<?>.class`는 허용하지 않는다.
* `instanceof` 연산자
  * **런타임에는 제네릭 타입 정보가 지워지므로** `instanceof` 연산자는 비한정적 와일드카드 타입 이외의 **매개변수화 타입은 적용할 수 없다.**
  * `instanceof`에서 로 타입과 비한정적 와일드카드 타입은 똑같이 동작한다.



<br>

### 정리

* 로 타입을 사용하면 런타임 예외가 발생할 수 있으니 꼭 사용해야 되는 경우를 제외하고, 사용하지 말자.