# 배열보다는 리스트를 사용하라

 ### 배열과 제네릭 타입의 차이

* **배열은 공변**이고, **제네릭은 불공변**이다.
  * 공변
    * `Sub`가 `Super`의 하위 타입일 때, 배열 `Sub[]`가 `Super[]`의 하위타입이 되는 것을 공변이라고 한다.
* **타입에 맞지 않는 값**을 넣으려고 할 때 **배열은 런타임**에 알 수 있지만, 리스트는 컴파일할 때 바로 알 수 있다.

```java
// 런타임 실패
Object[] objectArray = new Long[1];
objectArray[0] = "타입이 달라 값을 넣을 수 없다." // ArrayStoreException을 던진다.
```

```java
// 컴파일이 되지 않는다.
List<Object> ol = new ArrayList<Long>();
ol.add("타입이 달라 넣을 수 없다.") 
```

* **배열은 실체화**된다.
  * **배열은 런타임에도 자신이 담고 있는 원소의 타입을 인지**하기 때문에 타입에 맞지 않는 값을 넣으려고 하면 `ArrayStoreException`이 발생하지만, **제네릭은 타입 정보가 런타임에 소거**되기 때문에 런타임에는 타입 정보를 알 수 없다.
  * 이러한 차이로 **배열은 제네릭 타입, 매개변수화 타입, 타입 매개변수로 사용할 수 없다**.
    * `new List<E> []`, `new List<String>[]`, `new E[]` 처럼 사용하려고 하면 컴파일할 때, 제네릭 배열 생성 오류가 발생한다.
    * `E`, `List<E>`, `List<String>` 같은 타입을 **실체화 불가 타입**이라고 한다.
      * 실체화되지 않아서 **런타임에 컴파일타임보다 타입 정보를 적게 가지는 타입**
    * 소거 메커니즘 때문에 매개변수 타입 가운데, 실체화될 수 있는 타입은 `List<?>`, `Map<?, ?>`과 같은 비한정적 와일드카드 타입뿐이다.
    * 배열을 비한정적 와일드 카드 타입으로 만들 수 있지만, 유용하게 쓸 일은 거의 없다.

<br>

### 정리

* 배열과 제네릭은 다른 타입 규칙이 적용되기 때문에 이 둘을 섞어 쓰는건 쉽지 않다.
* 배열과 제네릭을 섞어 쓰다가 컴파일 오류나 경고를 만나면, 가장 먼저 배열을 리스트로 대체하는 방법을 적용해보자!
