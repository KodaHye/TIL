### Virtual Memory Management

* **ê°€ìƒ ë©”ëª¨ë¦¬(ê¸°ì–µì¥ì¹˜)**
  * Non-continuous allocation
    * ì‚¬ìš©ì í”„ë¡œê·¸ë¨ì„ blockìœ¼ë¡œ ë¶„í• í•˜ì—¬ ì ì¬/ì‹¤í–‰
  * Paging/Sementation system
* **ê°€ìƒ ë©”ëª¨ë¦¬ ê´€ë¦¬ì˜ ëª©ì **
  * ê°€ìƒ ë©”ëª¨ë¦¬ ì‹œìŠ¤í…œ **ì„±ëŠ¥ ìµœì í™”**
    * Cost model
    * ë‹¤ì–‘í•œ ìµœì í™” ê¸°ë²•



### Cost Model for Virtual Mem. Sys.

* **Page fault frequency (ë°œìƒ ë¹ˆë„)**
* **Page fault rate (ë°œìƒë¥ )**
* **Page fault rateë¥¼ ìµœì†Œí™” í•  ìˆ˜ ìˆë„ë¡ ì „ëµë“¤ì„ ì„¤ê³„í•´ì•¼ ë¨**
  * Context switch ë° Kernel ê°œì…ì„ ìµœì†Œí™”
  * ì‹œìŠ¤í…œ ì„±ëŠ¥ í–¥ìƒ
* **Page reference string (d)**
  * í”„ë¡œì„¸ìŠ¤ì˜ ìˆ˜í–‰ ì¤‘ ì°¸ì¡°í•œ í˜ì´ì§€ ë²ˆí˜¸ ìˆœì„œ
    $$
    Ï‰ = r_1r_2â‹¯r_kr_r\\
    r_i: í˜ì´ì§€\,ë²ˆí˜¸, \,r_i\,âˆˆ\,{0, 1, 2, â‹¯, N - 1} \\
    N: í”„ë¡œì„¸ìŠ¤ì˜\,í˜ì´ì§€\,ìˆ˜(0 \sim N - 1)\\
    |Ï‰|:\,Page\,Stringì˜\,ê¸¸ì´
    $$
* **Page fault rate = F(Ï‰)**
$$
F(Ï‰) = \frac{{Num.of\;page\;faluts\;during\;Ï‰}}{|Ï‰|}
$$


### Hardware Components

* **Address translation device(ì£¼ì†Œ ì‚¬ìƒ ì¥ì¹˜)**
  * ì£¼ì†Œ ì‚¬ìƒì„ íš¨ìœ¨ì ìœ¼ë¡œ ìˆ˜í–‰í•˜ê¸° ìœ„í•´ ì‚¬ìš©
    * E.g. TLB(associated memories), Dedicated page-table register, Cache memories
* **Bit Vectors**
  * Page ì‚¬ìš© ìƒí™©ì— ëŒ€í•œ ì •ë³´ë¥¼ ê¸°ë¡í•˜ëŠ” ë¹„íŠ¸ë“¤
  * **Reference bits (used bit)**
    * ì°¸ì¡° ë¹„íŠ¸
  * **Update bits (modified bits, write bits, dirty dits)**
    * ê°±ì‹  ë¹„íŠ¸



### Bit Vectors

* **Reference bit vector**
  <img src="../img/ìš´ì˜ì²´ì œ/Reference Bit Vector.png" width="80%">
  * ë©”ëª¨ë¦¬ì— ì ì¬ëœ **ê°ê°ì˜ pageê°€ ìµœê·¼ì— ì°¸ì¡°ë˜ì—ˆëŠ”ì§€**ë¥¼ í‘œì‹œ
  * ìš´ì˜
    1. í”„ë¡œì„¸ìŠ¤ì— ì˜í•´ ì°¸ì¡°ë˜ë©´ í•´ë‹¹ pageì˜ Ref.bitë¥¼ 1ë¡œ ì„¤ì •
    2. ì£¼ê¸°ì ìœ¼ë¡œ ëª¨ë“  reference bitë¥¼ 0ìœ¼ë¡œ ì´ˆê¸°í™”
  * Reference bitë¥¼ í™•ì¸í•¨ìœ¼ë¡œì¨ ìµœê·¼ì— ì°¸ì¡°ëœ pageë“¤ì„ í™•ì¸ ê°€ëŠ¥
* **Update bit vector**
  * Pageê°€ ë©”ëª¨ë¦¬ì— ì ì¬ëœ í›„, í”„ë¡œì„¸ìŠ¤ì— ì˜í•´ ìˆ˜ì •ë˜ì—ˆëŠ”ì§€ë¥¼ í‘œì‹œ
  * ì£¼ê¸°ì  ì´ˆê¸°í™” ì—†ìŒ
  * Update bit = 1
    * í•´ë‹¹ pageì˜ (Main memory ìƒ ë‚´ìš©) â‰  (Swap deviceì˜ ë‚´ìš©)
    * í•´ë‹¹ pageì— ëŒ€í•œ **Write-back (to swap device)** ì´ í•„ìš”



### Software Components

* **ê°€ìƒ ë©”ëª¨ë¦¬ ì„±ëŠ¥ í–¥ìƒì„ ìœ„í•œ ê´€ë¦¬ ê¸°ë²•ë“¤**
  * Allocation strategies (í• ë‹¹ ê¸°ë²•)
  * Fetch strategies
  * Placement strategies (ë°°ì¹˜ ê¸°ë²•)
  * Replacement strategies (êµì²´ ê¸°ë²•)
  * Cleaning strategies (ì •ë¦¬ ê¸°ë²•)
  * Load control strategies (ë¶€í•˜ ì¡°ì ˆ ê¸°ë²•)



### Allocation Strategies

* **ê° í”„ë¡œì„¸ìŠ¤ì—ê²Œ ë©”ëª¨ë¦¬ë¥¼ <u>ì–¼ë§ˆë§Œí¼ ì¤„ ê²ƒì¸ê°€</u>?**
  * **Fixed allocation (ê³ ì • í• ë‹¹)**
    * í”„ë¡œì„¸ìŠ¤ì˜ ì‹¤í–‰ ë™ì•ˆ ê³ ì •ëœ í¬ê¸°ì˜ ë©”ëª¨ë¦¬ë¥¼ í• ë‹¹
  * **Variable allocation (ê°€ë³€ í• ë‹¹)**
    * í”„ë¡œì„¸ìŠ¤ì˜ ì‹¤í–‰ë™ì•ˆ í• ë‹¹í•˜ëŠ” ë©”ëª¨ë¦¬ì˜ í¬ê¸°ê°€ ìœ ë™ì 
* **ê³ ë ¤ì‚¬í•­**
  * í”„ë¡œì„¸ìŠ¤ ì‹¤í–‰ì— í•„ìš”í•œ ë©”ëª¨ë¦¬ ì–‘ì„ ì˜ˆì¸¡í•´ì•¼ ë¨
  * **ë„ˆë¬´ í° ë©”ëª¨ë¦¬ í• ë‹¹ (Too much allocation)**
    * ë©”ëª¨ë¦¬ê°€ ë‚­ë¹„ë¨
  * **ë„ˆë¬´ ì ì€ ë©”ëª¨ë¦¬ í• ë‹¹ (Too small allocation)**
    * Page fault rate â†‘
    * ì‹œìŠ¤í…œ ì„±ëŠ¥ ì €í•˜



### Fetch Strategies

* **íŠ¹ì • pageë¥¼ ë©”ëª¨ë¦¬ì— <u>ì–¸ì œ ì ì¬í•  ê²ƒì¸ê°€</u>?**
  * **Demand fetch (demand paging)**
    * í”„ë¡œì„¸ìŠ¤ê°€ ì°¸ì¡°í•˜ëŠ” í˜ì´ì§€ë“¤ë§Œ ì ì¬
    * Page fault overhead
  * **Anticipatory fetch (pre-paging)**
    * ì°¸ì¡°ë  ê°€ëŠ¥ì„±ì´ ë†’ì€ page ì˜ˆì¸¡
    * ê°€ê¹Œìš´ ë¯¸ë˜ì— ì°¸ì¡°ë  ê°€ëŠ¥ì„±ì´ ë†’ì€ pageë¥¼ ë¯¸ë¦¬ ì ì¬
    * ì˜ˆì¸¡ ì„±ê³µì‹œ, page fault overheadê°€ ì—†ìŒ
    * Prediction overhead (Kernelì˜ ê°œì…), Hit ratioì— ë¯¼ê°í•¨
* **ì‹¤ì œ ëŒ€ë¶€ë¶„ì˜ ì‹œìŠ¤í…œì€ Demand fetch ê¸°ë²• ì‚¬ìš©**
  * ì¼ë°œì ìœ¼ë¡œ ì¤€ìˆ˜í•œ ì„±ëŠ¥ì„ ë³´ì—¬ì¤Œ
  * Anticipatory fetch
    * Prediction overhead, ì˜ëª»ëœ ì˜ˆì¸¡ ì‹œ ìì› ë‚­ë¹„ê°€ í¼



### Placement Strategies

* **Page/segmentë¥¼ <u>ì–´ë””ì— ì ì¬í•  ê²ƒì¸ê°€?</u>**
* **Paging systemì—ëŠ” ë¶ˆí•„ìš”**
* **Segmentation systemì—ì„œì˜ ë°°ì¹˜ ê¸°ë²•**
  * First-fit
  * Best-fit
  * Worst-fit
  * Next-fit



### Replacement Strategies

* **ìƒˆë¡œìš´ pageë¥¼ <u>ì–´ë–¤ pageì™€ êµì²´í•  ê²ƒì¸ê°€?</u> (ë¹ˆ page grameì´ ì—†ëŠ” ê²½ìš°)**
  * Fixed allocationì„ ìœ„í•œ êµì²´ ê¸°ë²•
    * MIN(OPT, BO) algorithm
    * Random algorithm
    * FIFO(First In First Out) algorithm
    * LRU(Least Recently Used) algorithm
    * NUR(Not Used Recently) algorithm
    * Clock algorithm
    * Second chance algorithm
  * Variable allocationì„ ìœ„í•œ êµì²´ ê¸°ë²•
    * VMIN(Variable MIN) algorithm
    * WS(Working Set) algorithm
    * PFF(Page Fault Frequency) algorithm 



### Cleaning Strategies

* **ë³€ê²½ ëœ pageë¥¼ <u>ì–¸ì œ write-back í•  ê²ƒì¸ê°€</u>?**
  * ë³€ê²½ëœ ë‚´ìš©ì„ swap deviceì— ë°˜ì˜
  * **Demand cleaning**
    * í•´ë‹¹ pageì— ë©”ëª¨ë¦¬ì—ì„œ ë‚´ë ¤ì˜¬ ë•Œ write-back
  * **Anticipatory cleaning (pre-cleaning)**
    * ë” ì´ìƒ ë³€ê²½ë  ê°€ëŠ¥ì„±ì´ ì—†ë‹¤ê³  íŒë‹¨í•  ë•Œ, ë¯¸ë¦¬ write-back
    * Page êµì²´ ì‹œ ë°œìƒí•˜ëŠ” wrtie-back ì‹œê°„ ì ˆì•½
    * Write-back ì´í›„, page ë‚´ìš©ì´ ìˆ˜ì •ë˜ë©´, overhead!
  * **ì‹¤ì œ ëŒ€ë¶€ë¶„ì˜ ì‹œìŠ¤í…œì€ Demand cleaning ê¸°ë²• ì‚¬ìš©**
    * ì¼ë°˜ì ìœ¼ë¡œ ì¤€ìˆ˜í•œ ì„±ëŠ¥ì„ ë³´ì—¬ì¤Œ
    * Anticipatory cleaning
      * Prediction overhead, ì˜ëª»ëœ ì˜ˆì¸¡ ì‹œ ìì› ë‚­ë¹„ê°€ í¼



### Load Control Strategies

* **ì‹œìŠ¤í…œì˜ multi-programming degree ì¡°ì ˆ**
  * Allocation strategiesì™€ ì—°ê³„ë¨
* **ì ì • ìˆ˜ì¤€ì˜ multi-programming degreeë¥¼ ìœ ì§€í•´ì•¼ ë¨**
  * Plateau(ê³ ì›) ì˜ì—­ìœ¼ë¡œ ìœ ì§€
  * ì €ë¶€í•˜ ìƒíƒœ(Under-loaded),
    * ì‹œìŠ¤í…œ ìì› ë‚­ë¹„, ì„±ëŠ¥ ì €í•˜
    * e.g. 100ê°œë¥¼ ì²˜ë¦¬í•  ìˆ˜ ìˆëŠ”ë° 10ê°œë¥¼ ì¤€ ê²½ìš°
  * ê³ ë¶€í•˜ ìƒíƒœ (Over-loaded),
    * ìì›ì— ëŒ€í•œ ê²½ìŸ ì‹¬í™”, ì„±ëŠ¥ ì €í•˜
    * e.g. 100ê°œë¥¼ ì²˜ë¦¬í•  ìˆ˜ ìˆëŠ”ë° 1000ê°œë¥¼ ì¤€ ê²½ìš°
    * **Thrashing(ìŠ¤ë ˆì‹±)** í˜„ìƒ ë°œìƒ
      * ê³¼ë„í•œ page faultê°€ ë°œìƒí•˜ëŠ” í˜„ìƒ



### Locality

* **í”„ë¡œì„¸ìŠ¤ê°€ í”„ë¡œê·¸ë¨/ë°ì´í„°ì˜ íŠ¹ì • ì˜ì—­ì„ ì§‘ì¤‘ì ìœ¼ë¡œ ì°¸ì¡°í•˜ëŠ” í˜„ìƒ**
* **ì›ì¸**
  * Loop structure in program
  * Array, structure ë“±ì˜ ë°ì´í„° êµ¬ì¡°
* **ê³µê°„ì  ì§€ì—­ì„±(Spatial locality)**
  * ì°¸ì¡°í•œ ì˜ì—­ê³¼ ì¸ì ‘í•œ ì˜ì—­ì„ ì°¸ì¡°í•˜ëŠ” íŠ¹ì„±
* **ì‹œê°„ì  ì§€ì—­ì„±(Temporal locality)**
  * í•œ ë²ˆ ì°¸ì¡°í•œ ì˜ì—­ì„ ê³§ ë‹¤ì‹œ ì°¸ì¡°í•˜ëŠ” íŠ¹ì„±



## Fixed allocation

### Min Algorithm (OPT algorithm)

* **1966ë…„ Beladyì— ì˜í•´ ì œì‹œ**
* **<u>Min</u>imize page fault frequency (proved)**
  * Optimal solution
* **ê¸°ë²•**
  * ì•ìœ¼ë¡œ ê°€ì¥ ì˜¤ë«ë™ì•ˆ ì°¸ì¡°ë˜ì§€ ì•Šì„ page êµì²´
    * Tie-breaking rule: page ë²ˆí˜¸ê°€ ê°€ì¥ í°/ì‘ì€ í˜ì´ì§€ êµì²´
* **ì‹¤í˜„ ë¶ˆê°€ëŠ¥í•œ ê¸°ë²• (Unrealizable)**
  * Page reference stringì„ ë¯¸ë¦¬ ì•Œê³  ìˆì–´ì•¼ ë¨
* **êµì²´ ê¸°ë²•ì˜ ì„±ëŠ¥ í‰ê°€ ë„êµ¬ë¡œ ì‚¬ìš©ë¨**



### Random Algorithm

* **ë¬´ì‘ìœ„ë¡œ êµì²´í•  page ì„ íƒ**
* **Low overhead**
* **No policy**
* ë˜ ë‹¤ë¥¸ ì„±ëŠ¥ í‰ê°€ì˜ ê¸°ì¤€ìœ¼ë¡œ ì‚¬ìš©ë  ìˆ˜ ìˆìŒ



### FIFO Algorithm

* **First In First Out**
  * ê°€ì¥ ì˜¤ë˜ëœ pageë¥¼ êµì²´
* **Pageê°€ ì ì¬ëœ ì‹œê°„ì„ ê¸°ì–µí•˜ê³  ìˆì–´ì•¼ ë¨**
* **ìì£¼ ì‚¬ìš©ë˜ëŠ” pageê°€ êµì²´ë  ê°€ëŠ¥ì„±ì´ ë†’ìŒ**
  * Localityì— ëŒ€í•œ ê³ ë ¤ê°€ ì—†ìŒ
* **FIFO anomaly(Belady's anomaly)**
  * FIFO ì•Œê³ ë¦¬ì¦˜ì˜ ê²½ìš°,
    ë” ë§ì€ page frameì„ í• ë‹¹ë°›ìŒì—ë„ ë¶ˆêµ¬í•˜ê³  page faultì˜ ìˆ˜ê°€ ì¦ê°€í•˜ëŠ” ê²½ìš°ê°€ ìˆìŒ



### LRU(Least Recently Used) Algorithm

* **ê°€ì¥ ì˜¤ë«ë™ì•ˆ ì°¸ì¡°ë˜ì§€ ì•Šì€ pageë¥¼ êµì²´**
* **Page ì°¸ì¡° ì‹œ ë§ˆë‹¤ ì‹œê°„ì„ ê¸°ë¡í•´ì•¼ ë¨**
* **Localityì— ê¸°ë°˜ì„ ë‘” êµì²´ ê¸°ë²•**
* **MIN algorithmì— ê·¼ì ‘í•œ ì„±ëŠ¥ì„ ë³´ì—¬ì¤Œ**
* **ì‹¤ì œë¡œ ê°€ì¥ ë§ì´ í™œìš©ë˜ëŠ” ê¸°ë²•**
* **ë‹¨ì **
  * ì°¸ì¡° ì‹œ ë§ˆë‹¤ ì‹œê°„ì„ ê¸°ë¡í•´ì•¼ ë¨(Overhead)
    * ê°„ì†Œí™”ëœ ì •ë³´ ìˆ˜ì§‘ìœ¼ë¡œ í•´ì†Œ ê°€ëŠ¥
      * ì˜ˆ) ì •í™•í•œ ì‹œê°„ ëŒ€ì‹ , ìˆœì„œë§Œ ê¸°ë¡
  * Loop ì‹¤í–‰ì— í•„ìš”í•œ í¬ê¸°ë³´ë‹¤ ì‘ì€ ìˆ˜ì˜ page frameì´ í• ë‹¹ëœ ê²½ìš°, page fault ìˆ˜ê°€ ê¸‰ê²©íˆ ì¦ê°€í•¨
    * e.g. loopë¥¼ ìœ„í•œ |Ref.string| = 4 / í• ë‹¹ëœ page frameì´ 3ê°œ
    * Allocation ê¸°ë²•ì—ì„œ í•´ê²°í•´ì•¼ ë¨



### LFU(Least Frequently Used) Algorithm

* **ê°€ì¥ ì°¸ì¡° íšŸìˆ˜ê°€ ì ì€ Pageë¥¼ êµì²´**
  * Tie-breaking rule: LRU
* **Page ì°¸ì¡° ì‹œ ë§ˆë‹¤, ì°¸ì¡° íšŸìˆ˜ë¥¼ ëˆ„ì  ì‹œì¼œì•¼ í•¨**
* **Locality í™œìš©**
  * LRU ëŒ€ë¹„ ì ì€ overhead
* **ë‹¨ì **
  * ìµœê·¼ ì ì¬ëœ ì°¸ì¡°ë  ê°€ëŠ¥ì„±ì´ ë†’ì€ pageê°€ êµì²´ë  ê°€ëŠ¥ì„±ì´ ìˆìŒ
  * ì°¸ì¡° íšŸìˆ˜ ëˆ„ì  overhead



### NUR(Not Used Recently) Algorithm

* **LRU approximation scheme**
  * LRUë³´ë‹¤ ì ì€ overheadë¡œ ë¹„ìŠ·í•œ ì„±ëŠ¥ ë‹¬ì„± ëª©ì 
* **Bit vector ì‚¬ìš©**
  * Reference bit vector (r), Update bit vector (m)
* **êµì²´ ìˆœì„œ**
  1. (r, m) = (0, 0)
  2. (r, m) = (0, 1)
  3. (r, m) = (1, 0)
  4. (r, m) = (1, 1)



### Clock Algorithm

* **IBM VM/370 OS**
* **Reference bit ì‚¬ìš©í•¨**
  * ì£¼ê¸°ì ì¸ ì´ˆê¸°í™” ì—†ìŒ
* **Page frame ë“¤ì„ ìˆœì°¨ì ìœ¼ë¡œ ê°€ë¦¬í‚¤ëŠ” pointer(ì‹œê³„ë°”ëŠ˜)ë¥¼ ì‚¬ìš©í•˜ì—¬ êµì²´ë  page ê²°ì •**
* **Pointerë¥¼ ëŒë¦¬ë©´ì„œ êµì²´ page ê²°ì •**
  * í˜„ì¬ ê°€ë¦¬í‚¤ê³  ìˆëŠ” pageì˜ reference bit(r) í™•ì¸
  * r = 0ì¸ ê²½ìš°, êµì²´ pageë¡œ ê²°ì •
  * r = 1ì¸ ê²½ìš°, reference bit ì´ˆê¸°í™” í›„ pointer ì´ë™
* **ë¨¼ì € ì ì¬ëœ pageê°€ êµì²´ë  ê°€ëŠ¥ì„±ì´ ë†’ìŒ**
  * FIFOì™€ ìœ ì‚¬
* **Reference bitë¥¼ ì‚¬ìš©í•˜ì—¬ êµì²´ í˜ì´ì§€ ê²°ì •**
  * LRU (or NUR)ê³¼ ìœ ì‚¬



### Second Chance Algorithm

* **Clock algorithmê³¼ ìœ ì‚¬**
* **Update bit (m)ë„ í•¨ê»˜ ê³ ë ¤í•¨**
  * í˜„ì¬ ê°€ë¦¬í‚¤ê³  ìˆëŠ” pageì˜ (r, m) í™•ì¸
  * (0, 0): êµì²´ pageë¡œ ê²°ì •
  * (0, 1): â†’ (0, 0), write-back (cleaning) listì— ì¶”ê°€ í›„ ì´ë™ 
  * (1, 0): â†’ (0, 0) í›„ ì´ë™
  * (1, 1): â†’ (0, 1) í›„ ì´ë™



### Other Algorithms

* **Additional-reference-bits algorithm**
  * LRU approximation
  * ì—¬ëŸ¬ ê°œì˜ reference bitë¥¼ ê°€ì§
    * ê° time-intervalì— ëŒ€í•œ ì°¸ì¡° ì—¬ë¶€ ê¸°ë¡
    * History register for each page
* **MRU (Most Recently Used) algorithm**
  * LRUì™€ ì •ë°˜ëŒ€ ê¸°ë²•
* **MFU (Most Frequently Used) algorithm**
  * LFUì™€ ì •ë°˜ëŒ€ ê¸°ë²•



## Variable allocation

### Working Set(WS) algorithm

* **1968ë…„ Denningì´ ì œì•ˆ**
* **Working set**
  * Processê°€ **íŠ¹ì • ì‹œì ì— ìì£¼ ì°¸ì¡°**(locality)í•˜ëŠ” pageë“¤ì˜ ì§‘í•©
  * ìµœê·¼ ì¼ì •ì‹œê°„ ë™ì•ˆ(Î”) ì°¸ì¡°ëœ pageë“¤ì˜ ì§‘í•©
  * ì‹œê°„ì— ë”°ë¼ working setì´ ë³€í•  ìˆ˜ ìˆìŒ
  * W(t, Î”)
    * The working set of a process at time t
    * Time interval [t - Î”, t] ë™ì•ˆ ì°¸ì¡°ëœ pagesë“¤ì˜ ì§‘í•©
    * Î”: window size, system parameter
* **Working set memory management**
  * Localityì— ê¸°ë°˜
  * Working setì„ ë©”ëª¨ë¦¬ì— í•­ìƒ ìœ ì§€
    * Page fault rate (thrashing) ê°ì†Œ
    * ì‹œìŠ¤í…œ ì„±ëŠ¥ í–¥ìƒ
  * Window size(Î”)ëŠ” ê³ ì •
    * Memory allocationì€ ê°€ë³€
      * ë°˜ëŒ€ë¡œ, MAê°€ ê³ ì • and Î”ê°€ ê°€ë³€ì´ë¼ë©´ LRUë¼ê³  ìƒê°í•  ìˆ˜ ìˆìŒ
    * Î” ê°’ì´ ì„±ëŠ¥ì„ ê²°ì • ì§“ëŠ” ì¤‘ìš”í•œ ìš”ì†Œ
* **Window size(Î”) vs WS size(MA)**
  <img src = "../img/ìš´ì˜ì²´ì œ/Working Set Algorithm.png" width = "80%">
  * ì§€ì—­ì„±ìœ¼ë¡œ ì¸í•´ ì´ˆë°˜ì—ëŠ” window sizeë¥¼ ì¡°ê¸ˆë§Œ ì¦ê°€ì‹œì¼œë„ working set sizeê°€ ë§ì´ ëŠ˜ì–´ë‚¨
* **Working set transition**
  <img src = "../img/ìš´ì˜ì²´ì œ/Working set Transition.png" width ="80%">
* **ì„±ëŠ¥ í‰ê°€**
  * Page fault ìˆ˜ ì™¸ ë‹¤ë¥¸ ì§€í‘œë„ í•¨ê»˜ ë´ì•¼ ë¨
  * Example
    * Time interval [1, 10]
      * \# of page fault = 5
      * í‰ê·  í• ë‹¹ page frame ìˆ˜ = 3.2
    * í‰ê°€
      * í‰ê·  3.2ê°œì˜ page frameì„ í• ë‹¹ë°›ì€ ìƒíƒœì—ì„œ 5ë²ˆì˜ page fault ë°œìƒ
* **íŠ¹ì„±**
  * ì ì¬ë˜ëŠ” pageê°€ ì—†ë”ë¼ë„, ë©”ëª¨ë¦¬ë¥¼ ë°˜ë‚©í•˜ëŠ” pageê°€ ìˆì„ ìˆ˜ ìˆìŒ
  * ìƒˆë¡œ ì ì¬ë˜ëŠ” pageê°€ ìˆë”ë¼ë„, êµì²´ë˜ëŠ” pageê°€ ì—†ì„ ìˆ˜ ìˆìŒ
* **ë‹¨ì **
  * Working set management overhead
  * Residence set(ìƒì£¼ ì§‘í•©)ì„ Page faultê°€ ì—†ë”ë¼ë„, ì§€ì†ì ìœ¼ë¡œ ê´€ë¦¬í•´ì•¼ ë¨



### Page Fault Frequency(PFF) algorithm

* **Residence set sizeë¥¼ page fault rateì— ë”°ë¼ ê²°ì •**
  * Low page fault rate (long inter-fault time)
    * Processì—ê²Œ í• ë‹¹ëœ PF ìˆ˜ë¥¼ ê°ì†Œ
  * High page fault rate (short inter-fault time)
    * Processì—ê²Œ í• ë‹¹ëœ PF ìˆ˜ë¥¼ ì¦ê°€
* **Resident set ê°±ì‹  ë° ë©”ëª¨ë¦¬ í• ë‹¹**
  * Page faultê°€ ë°œìƒì‹œì—ë§Œ ìˆ˜í–‰
  * Low overhead
* **Criteria for page fault rate:**
  * IFT: inter-fault time
  * IFT > ğœ: Low page fault rate
  * IFT < ğœ: High page fault rate
  * ğœ: threshold value
    * System parameter
* **Algorithm**
  1. Page fault ë°œìƒ ì‹œ, IFT ê³„ì‚°
     * IFT = t_c - t_c-1
       * t_c-1: time of previous page fault
       * t_c: time of current page fault
  2. IFT > ğœ (Low page fault rate)
     * Residence set â† (t_c-1, t_c] ë™ì•ˆ ì°¸ì¡°ëœ pageë“¤ë§Œ ìœ ì§€
     * ë‚˜ë¨¸ì§€ pageë“¤ì€ ë©”ëª¨ë¦¬ì—ì„œ ë‚´ë¦¼
        * ë©”ëª¨ë¦¬ í• ë‹¹(#of page frames) ìœ ì§€ or ê°ì†Œ
  3. IFT â‰¤ ğœ (High page fault rate)
     * ê¸°ì¡´ pagesë“¤ ìœ ì§€
     * + í˜„ì¬ ì°¸ì¡°ëœ pageë¥¼ ì¶”ê°€ ì ì¬
        * ë©”ëª¨ë¦¬ í• ë‹¹(#of page frames) ì¦ê°€
* **ì„±ëŠ¥ í‰ê°€**
  * Page fault ìˆ˜ ì™¸ ë‹¤ë¥¸ ì§€í‘œë„ í•¨ê»˜ ë´ì•¼ ë¨
  * Example
    * Time interval [1, 10]
      * \# of page fault = 5
      * í‰ê·  í• ë‹¹ page frame ìˆ˜ = 3.7
    * í‰ê°€
      * í‰ê·  3.7ê°œì˜ page frameì„ í• ë‹¹ë°›ì€ ìƒíƒœì—ì„œ 5ë²ˆì˜ page fault ë°œìƒ
* **íŠ¹ì§•**
  * ë©”ëª¨ë¦¬ ìƒíƒœ ë³€í™”ê°€ page fault ë°œìƒ ì‹œì—ë§Œ ë³€í•¨
    * Low overhead 



### Variable MIN(VMIN) algorithm

* **Variable allocation ê¸°ë°˜ êµì²´ ê¸°ë²• ì¤‘ optimal algorithm**
  * í‰ê·  ë©”ëª¨ë¦¬ í• ë‹¹ëŸ‰ê³¼ page fault ë°œìƒ íšŸìˆ˜ ëª¨ë‘ ê³ ë ¤í–ˆì„ ë•Œì˜ Optimal
* **ì‹¤í˜„ ë¶ˆê°€ëŠ¥í•œ ê¸°ë²• (Unrealizable)**
  * Page reference stringì„ ë¯¸ë¦¬ ì•Œê³  ìˆì–´ì•¼ ë¨
* **ê¸°ë²•**
  * [t, t + Î”]ì„ ê³ ë ¤í•´ì„œ êµì²´í•  page ì„ íƒ
* **Algorithm**
  * Page rì´ t ì‹œê°„ì— ì°¸ì¡°ë˜ë©´, page rì´ [t, t + Î”] ì‚¬ì´ì— ë‹¤ì‹œ ì°¸ì¡°ë˜ëŠ”ì§€ í™•ì¸
  * ì°¸ì¡°ëœë‹¤ë©´, page rì„ ìœ ì§€
  * ì°¸ì¡°ë˜ì§€ ì•ŠëŠ”ë‹¤ë©´, page rì„ ë©”ëª¨ë¦¬ì—ì„œ ë‚´ë¦¼
* **ì„±ëŠ¥ í‰ê°€**
  * Page fault ìˆ˜ ì™¸ ë‹¤ë¥¸ ì§€í‘œë„ í•¨ê»˜ ë´ì•¼ ë¨
  * Example
    * Time interval [1, 10]
      * \# of page fault = 5
      * í‰ê·  í• ë‹¹ page frame ìˆ˜ = 1.6
    * í‰ê°€
      * í‰ê·  1.6ê°œì˜ page frameì„ í• ë‹¹ë°›ì€ ìƒíƒœì—ì„œ 5ë²ˆì˜ page faultê°€ ë°œìƒ
* **ìµœì  ì„±ëŠ¥ì„ ìœ„í•œ Î”ê°’ì€?**
  * $$
    Î” = \frac{R}{U}
    $$
    * U: í•œ ë²ˆì˜ ì°¸ì¡° ì‹œê°„ ë™ì•ˆ pageë¥¼ ë©”ëª¨ë¦¬ì— ìœ ì§€í•˜ëŠ” ë¹„ìš©
    * R: page fault ë°œìƒ ì‹œ ì²˜ë¦¬ ë¹„ìš©
  * R > Î” * U, (Î”ê°€ ì‘ìœ¼ë©´)
    * ì²˜ë¦¬ ë¹„ìš© > page ìœ ì§€ ë¹„ìš©
  * R < Î” * U, (Î”ê°€ í¬ë©´)
    * page fault ì²˜ë¦¬ ë¹„ìš© < ìœ ì§€ ë¹„ìš©



## Other Considerations

### Page Size

* **ì‹œìŠ¤í…œ íŠ¹ì„±ì— ë”°ë¼ ë‹¤ë¦„**
  * No best answer ( í•­ìƒ ì ë‹¹í•œ ê²ƒì´ ì¢‹ë‹¤... )
  * **ìš”ì¦˜ì€ ì‹œìŠ¤í…œì€ í˜ì´ì§€ í¬í‚¤ê°€ ì ì  ì»¤ì§€ëŠ” ê²½í–¥ì´ ìˆë‹¤..**
    * ìµœê·¼ CPUì™€ Memory sizeê°€ ì»¤ì§€ê³  ìˆë‹¤ !!
    * ë³‘ëª©í˜„ìƒì˜ ê°€ëŠ¥ì„±ì´ ë†’ì•„ì§€ê¸° ë•Œë¬¸ì— I/O ì‹œê°„ì„ ê°ì†Œì‹œí‚¤ëŠ”ê²Œ ì¤‘ìš”í•¨ !
* **ì¼ë°˜ì ì¸ page size**
  * 128 bytes ~ 4M bytes
* **Small page size**
  * Large page table / # of PF
    * High overhead(kernel)
  * ë‚´ë¶€ ë‹¨í¸í™” ê°ì†Œ
  * I/O ì‹œê°„ ì¦ê°€
  * Locality í–¥ìƒ
  * Page fault ì¦ê°€
* **Large page size**
  * Small page table / # of PE
    * Low overhead(kernel)
  * ë‚´ë¶€ ë‹¨í¸í™” ì¦ê°€
  * I/O ì‹œê°„ ê°ì†Œ
  * Locality ì €í•˜
  * Page fault ê°ì†Œ



### Program Restructuring

* **ê°€ìƒ ë©”ëª¨ë¦¬ ì‹œìŠ¤í…œì˜ íŠ¹ì„±ì— ë§ë„ë¡ í”„ë¡œê·¸ë¨ì„ ì¬êµ¬ì„±**
* **ì‚¬ìš©ìê°€ ê°€ìƒ ë©”ëª¨ë¦¬ ê´€ë¦¬ ê¸°ë²•(ì˜ˆ, paging system)ì— ëŒ€í•´ ì´í•´í•˜ê³  ìˆë‹¤ë©´, <u>í”„ë¡œê·¸ë¨ì˜ êµ¬ì¡°ë¥¼ ë³€ê²½í•˜ì—¬ ì„±ëŠ¥ì„ ë†’ì¼ ìˆ˜ ìˆìŒ</u>**



### TLB Reach

* **TLBë¥¼ í†µí•´ ì ‘ê·¼í•  ìˆ˜ ìˆëŠ” ë©”ëª¨ë¦¬ì˜ ì–‘**
  * (The number of entries) * (the page size)
* **TLBì˜ hit ratioë¥¼ ë†’ì´ë ¤ë©´,**
  * TLBì˜ í¬ê¸° ì¦ê°€
    * Expensive
  * Page í¬ê¸° ì¦ê°€ or ë‹¤ì–‘í•œ page size ì§€ì›
    * OSì˜ ì§€ì›ì´ í•„ìš”
      * ìµœê·¼ OSì˜ ë°œì „ ê²½í–¥